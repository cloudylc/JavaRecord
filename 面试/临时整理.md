# 基础

# 并发

## 线程池

**JDK内部最小单元：**`ThreadPoolExecutor`

**JDK实现的框架**:`Executor`

* `newCachedThradPool`
* `newFixedThreadPool`
* `newSingleThreadExecutor`
* `newScheduleThreadPool`
* `newSingleThreadScheduledExecutor`

**SpringBoot的线程池**：`ThreadPoolTaskExecutor`



# 集合

## HashMap

* 底层 `Node<K,V>[] table`
* Hash表解决哈希冲突的方法
  * 开放地址法
  * **链地址法：数组 + 链表**
* 几个初始化参数

~~~java
/** 
  极限<k,v>对，超过了就resize(), 公式： threshold = length * loadFactor 
*/
int threshold;

/** 
  负载因子，默认 0.75 
*/
float loadFactor;

/**
  记录内部结构发生变化的次数 
*/
int modCount;

/** 
  实际的<k,v>对 
*/
int size;

/** 
  table的长度，一定是2的n次方 
*/
int length;
~~~



**确定哈希桶数组索引位置：**

`h = (key.hashCode()) ^ (key.hashCode() >>>16)`

理论上：`h % length`

优化：`h & (length - 1)`

结论：效果等价，效率更快



**并发+版本问题：**

* jdk1.7 :
  * 在并发插入元素时，有可能会出现带环链表，让下一次读操作出现死循环
  * 数组 + 链表
  * 头插法
* Jdk 1.8 
  * 并发下数据覆盖
  * 数组 + 链表 + 红黑树
  * 尾插发
* 线程安全解决方案：
  * HashTable、Collections.SynchronizedMap() : 全局锁，会阻塞其他操作，有性能问题
  * ConcurrentHashMap() : jdk1.7 有 Segmentl 的一个二级哈希表概念，写入加锁



## ConcurrentHashMap

Jdk1.7 有分段概念，其包含着许多小的`Map`叫做 `Segment`，而`Segment`里面也包含着真正的`HashMap`

* 二级哈希表
* 所有哈希操作都要进行2次
* 写入时才加锁，锁的是`Segment`

# JVM

## 内存区域

**JDK1.6**

运行时数据区域

~~~markdown
* 线程共享
			1. 堆
			2. 方法区
					运行时常量池（字符串常量池）
					Class
					ClassLoader
			
* 线程私有
			1.虚拟机栈
			2.本地方法栈
			3.程序计数器
~~~

本地内存

~~~markdown
* 直接内存
~~~

***

**JDK1.8**

运行时数据区域

~~~markdown
* 线程共享
			1. 堆
				 字符串常量池
			
* 线程私有
			1.虚拟机栈
			2.本地方法栈
			3.程序计数器
~~~

本地内存

~~~markdown
* 元空间
		运行时常量池
		Class
		ClassLoader

* 直接内存
~~~



**堆**

* JVM管理内存中最大的一块
* 唯一目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存
* GC堆，细分成新生代和老年代，就是 Eden空间、From Survivor、To Survivor。为了更好回收垃圾 / 更快分配内存。

**方法区**

* 存储已被虚拟机加载的类信息、常量、静态变量、即时编辑器编译后的代码等

**直接内存**

* 也可能导致 OOM
* 避免IO操作时，数据在 Java 堆中和 Native 堆之间来回复制数据



**终结String创建对象问题：**

~~~java
/**
	字面量创建：
		1、查询字符串常量池中有没有"fuck"
		2、如果有，则返回字符串常量池中“fuck”的地址，无需额外创建
			 如果没有，则在字符串常量池中创建"fuck"对象，并返回字符串常量池中"fuck"的地址
*/
String a = "fuck";


/**
	new对象创建：
		1、在堆中创建 String("you") 这个对象，然后检查字符串常量池中有无 "you"
		2、如果没有，则在字符串常量池中创建 "you"
		   如果有，则啥事不干
		3、返回堆中 String("you") 的地址
*/
String b = new String("you");


/**
	解析 xxx.intern()方法：
		该方法就是返回 xxx 在字符串常量池中的地址
*/
String bb = b.intern();
~~~



## 垃圾回收

**垃圾标记法**

* 引用计数法
  * 对象被引用时，自身的计数器+1，为0时就代表对象不可用
  * 缺点：循环引用：两个对象互相引用
* 可达性分析
  * 以 GC Root 为起点的引用链进行对象的寻找，能找到就是可达的就标记为非垃圾对象，未标记的就是不可达对象就是垃圾。
  * GC Root 下面的对象：
    * 虚拟机栈(栈帧中的本地变量表)中引用的对象
    * 本地方法栈(Native 方法)中引用的对象
    * 方法区中类静态属性引用的对象
    * 方法区中常量引用的对象
    * 所有被同步锁持有的对象



**引用类型**

* 强引用(StrongReference)：垃圾回收器绝对不会回收，即使 OOM  也不会
* 软引用(SoftReference)：内存不足时会回收。软引用可实现内存敏感的高速缓存。
* 弱引用(WeakReference)：垃圾回收器一发现就会回收，不过GC线程优先级低，所以弱引用对象有短暂的生命周期
* 虚引用(PhantomReference)：任何时候都可以能回收，主要用来跟踪对象被垃圾回收的活动。



**垃圾收集算法（方法论）**

* 标记-清除算法（后续都是弥补它缺点）
  * 标记后，把垃圾对象直接删除，会产生很多碎片
* 标记-复制算法
  * 标记后，开辟新的空间，把存活对象整齐的复制到新空间中
* 标记-整理算法
  * 标记后，不直接回收垃圾对象，而是让所有存活对象向一端移动（覆盖垃圾），然后清理那些未被覆盖的垃圾
* 分代收集算法
  * 新生代每次收集都会有大量对象死去，所以可以选择 ”标记-复制“ 算法，因为能活下来被复制的对象少，还能减少碎片的产生
  * 老年代的对象存活几率较高，且没有额外空间进行操作，所以必须选择 ”标记-清除“ 和 ”标记-整理“ 算法

**垃圾收集器（实现）**

* Serial 收集器
* ParNew 收集器
* Parallel Scavenge 收集器
* CMS 收集器
* G1 收集器



## 对象

**Hotspot JVM中对象的内存布局:**

对象：

* 对象头
  * 对象自身的运行时数据（哈希吗、GC分代年龄、锁状态标志等等）
  * 类型指针：指向它类元数据的指针。JVM通过它确定该对象是哪个类的实例
* 实例数据：程序中定义的信息
* 对齐填充：占位，因为 Hotspot 要求对象的起始地址必须是 8 字节的整数倍。



**Java创建对象过程：**

1. 类加载检查
2. 分配内存
3. 初始化零值
4. 设置对象头
5. 执行 init() 方法



**包装类**

* 为什么要有包装类？
  * Java 是面向对象语言，所有类型都是引用类型，int 不是引用类型，所以需要包装类来保证 Java 面向对象的完整性。
  * 集合只能放引用类型
* 自动装箱与自动拆箱
  * 装箱：调用 valueOf() 方法，有缓存机制
  * 拆箱：调用 xxxValue()方法

## 







# Redis

### 理论

**原子操作，支持事务**

**5.0之前是单线程，但是**

* 网络IO、K-V读写由主线程完成
* 持久化、异步删除、集群数据同步由额外的线程完成

**速度快的原因**

* CPU不是瓶颈，瓶颈在于机器内存和网络带宽

* 基于内存级别的运算，单线程操作
  * 避免多线程的上下文切换所带来的性能损耗
  * 不用考虑锁的问题
* 使用IO多路复用模型，非阻塞IO



**SpringBoot使用方式：**

* 直接通过 `RedisTemplate` 来使用
* 使用 `Spring Cache` 集成 `Redis`



**适用场景：**

* 读密集（热点数据）
* 响应时效高
* 一致性要求低
* 需要分布式锁

**不适用：**

* 一致性要求高
* 更新频繁
* 读少



**缓存问题：**

* 数据不一致
* 缓存击穿：某一 `key` 失效，多请求查库
  * 设置热点数据永不过期，做好数据同步就行
* 缓存雪崩：多个缓存击穿
  * 把每个`key`的失效时间都加个随机值，防止统一时间大面积失效
  * 集群情况下，把热点数据放置不同的库中
* 缓存穿透：查询一定不在 缓存 也不在 库 的数据
  * 接口层做校验：用户鉴权，参数校验
  * Redis布隆过滤器，判断这个`key`是否在库中



### 缓存淘汰策略

* LRU：最近最少使用，每次使用都插入到队尾，超出队列长度就淘汰
* LFU：最近最少频率使用，额外开辟空间统计使用频率
* FIFO：先进先出

**Redis有六种淘汰策略**



### 持久化策略

**RDB**

* 以快照的形式将数据保存到一个 dump.rdb 的二进制文件中
* 默认持久化方式
* 触发条件：n秒n次改动
* 原理：Redis需要做持久化时，会 fork 一个子进程，这个子进程将数据写到磁盘一个临时RDB文件中

**AOF**

* 将修改的命令都保存到 appendonly.aof 文件中
* 触发条件：配置文件中 `appendonly yes`
* 配置记录频率：`appendfsync：` always  everysec  no



### 数据结构

**5种应用结构：String、List、Hash、Set、ZSet**

**3种特殊的：Geo、HyperLogLog、Bitmaps**

**1. String**

* 二进制安全，可以包含任何数据，对象、图片的序列化后的对象，最大 512M

* 怎么存就怎么出，没有额外改变。

~~~redis
# 单值缓存
set key value
get key

# 用途1： 对象缓存，如实现分布式 Session,其中 key 为 sessionId, value 为用户对象
mset user_name Jerry userAge 25
mget user_name user_age

# 用途2：计数器（限流、阅读数、点赞数、分布式唯一id）
#自增 自减 加N 减N
incr num
decr num
incrby num N
decrby num N

# 用途3：分布式锁。返回 1 获取锁成功，返回 0 失败
setnx key valye
~~~

**2. List**

~~~redis
# 能实现 队列、栈、阻塞队列

# 用途1：实现队列
Lpush 
Rpop

# 用途2：实现栈
Lpush
Lpop

# 用途3：实现阻塞队列
Lpush
BRpop

# 用途4：消息推送，比如公众号的消息推送
# 公众号A发了篇文章
Lpush  msg_公众号A的id 文章id
# 查看公众号 A 最新的消息，一页4个
Lrang  msg_公众号A的id  0 4
~~~

**3.Hash**

~~~redis
# 对象缓存，经典实现购物车
hmset user name Jerry age 25
hmget user name age

# 购物车的实现：
# 添加商品到购物车：
hset cart_用户id  商品id  购买数量

# 增加购物车商品的数量
hincrby cart_用户id 商品id 需要增加的数量

# 获取该用户的商品总数
hlen cart_用户id

# 删除该用户的购物车
hdel cart_用户id

# 获取购物车的所有商品
hgetall cart_用户id
~~~

**4.Set**

~~~redis
# 无序集合
# 交集 差集 并集
~~~

**5.ZSet**

~~~redis
# 有序集合
~~~

**6.特殊**

* Geo: 存储地理位置信息，做地理位置定位的
* HyperLogLog: 做基数统计算法的数据结构，如统计网站的UV
* Bitmpas: 用一个比特位来映射某个元素的状态，就好像一个比特数组，能实现布隆过滤器

# MongoDB

# Netty



# Caffeine

# RabbitMQ

**3大原则**

* 解耦
* 异步
* 削峰



# 设计模式

## 5原则3模式

**SOLID原则**

* 单一原则
* 开闭原则
* 里氏替换原则
* 接口隔离原则
* 依赖翻转原则



**3种模式**

* 创建型模式
* 结构型模式
* 行为模式



## 单例模式

## 工厂模式

## 策略模式

# SpringCloud

## Eureka

## Feign

# 阿里巴巴规范

# 面经

~~~
1.hashmap实现原理，怎么减少hash碰撞
2.几种线程池
3.启动线程的方式
4.redis五种类型，持久化机制，项目中怎么用的
5.spring源码看过没？bean的生命周期 aop实现原理
6.springcloud组件挨个介绍
7.springboot启动流程
8.常用设计模式
9.用docker来干嘛  说几个简单命令
10.为什么用rabbitmq
11.项目 问的很细节
~~~

~~~
1、JWT相关
2、场景题目：如何限流，单个接口访问速率限制
		（固定窗口、滑动窗口、漏桶算法、令牌桶算法）
3、如何实现单点登录
4、Java内存区域
5、常量、字符串缓冲池


~~~

~~~
1. 基本类型有哪些，第一个问题一紧张就只说出来7个，少说一个
2. 基本类型对应包装类，缓冲池，为什么要有包装类
3. 说说MySQL，知道的都说一说
4. 简单说说集合
5. 垃圾回收算法有哪些
6. Redis雪崩，穿透
7. 画一下微服务架构
8. 四种引用强软弱虚
9. GCROOT，新生代老年代比例
10. 超卖问题
11. 分布式锁如何实现，命令与Redisson
12. 单点登录，微信扫码登录
13. MyBatis 一对多，多对多，接口与xml关联，插件机制，有了MB为什么还有MP
14. 写线程安全单例模式，写了DCL，真的安全吗？反射创建呢？枚举单例
~~~

